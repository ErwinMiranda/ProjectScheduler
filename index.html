<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ProjSchedâ€” Scheduler & Dependencies</title>
    <style>
      :root {
        --left-width: clamp(380px, 32vw, 450px);
        --row-height: 44px;
        --bar-height: 20px;
        --grid-bg: #f7f9fb;
        --accent: #0c2868;
        --muted: #6b7280;
        --card: #ffffff;
        --scale: 36px;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        font-family: "Segoe UI", Roboto, system-ui, sans-serif;
        color: #111827;
        background: #eef2f6;
      }

      /* App container */
      .app {
        display: flex;
        flex-direction: column;
        height: 100vh;
        gap: 12px;
        padding: 12px;
        box-sizing: border-box;
      }

      .panel {
        background: var(--card);
        border-radius: 10px;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.06);
        overflow: hidden;
      }

      /* HEADER */
      .header-panel {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
      }
      .header-left {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .title {
        font-weight: 600;
      }
      .header-controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      select,
      input[type="text"],
      input[type="date"] {
        padding: 8px;
        border-radius: 8px;
        border: 1px solid #e6edf6;
        background: white;
      }

      /* GANTT area: single scroll container */
      .gantt-panel {
        display: flex;
        flex: 1 1 auto;
        min-height: 0;
      } /* parent of scroll area */
      .gantt-scroll {
        flex: 1 1 auto;
        overflow: auto; /* single scroll box (both axes) */
        display: flex;
        min-height: 0;
        background: transparent;
      }

      .gantt-inner {
        display: flex;
        min-width: 100%;
        min-height: 0;
      }

      /* Left column (task info) */
      .gantt-left {
        width: var(--left-width);
        min-width: var(--left-width);
        box-sizing: border-box;
        border-right: 1px solid #eef2f6;
        background: transparent;
        display: flex;
        flex-direction: column;
      }

      /* Right column (timeline) */
      .gantt-right {
        flex: 1 1 auto;
        min-width: 600px; /* allows horizontal scrolling */
        display: flex;
        flex-direction: column;
        position: relative;
        background: transparent;
      }

      /* left column header row to match timeline header height */
      .left-header {
        height: 60px;
        padding: 10px 12px;
        box-sizing: border-box;
        border-bottom: 1px solid #eef2f6;
        background: #fff;
      }

      /* timeline header (inside right column) */
      .timeline-header {
        position: sticky;
        top: 0;
        z-index: 5;
        display: flex;
        align-items: center;
        height: 44px;
        padding: 8px;
        background: rgba(255, 255, 255, 0.9);
        border-bottom: 1px solid #eef2f6;
      }

      /* rows container */
      .rows-container {
        display: flex;
        flex-direction: column;
        min-width: 0;
      }

      /* each unified row */
      .unified-row {
        display: flex;
        align-items: center; /* allow multi-line content */
        min-height: var(--row-height); /* 44px minimum but can grow */
        padding: 0;
        box-sizing: border-box;
        border-bottom: 1px dashed #f1f5f9;
        background: white;
      }
      .row-left,
      .row-right {
        padding-top: 4px;
        padding-bottom: 4px;
      }
      /* left cell content inside unified row */
      .row-left {
        width: var(--left-width);
        min-width: var(--left-width);
        padding: 0 12px;
        display: flex;
        align-items: center;
        gap: 16px;
        box-sizing: border-box;
      }
      .index {
        color: var(--muted);
      }
      .task-title {
        flex: 1;
        min-width: 0;
        font-size: 12px;
        white-space: normal; /* allow wrapping! */
        overflow-wrap: break-word;
        line-height: 1.3;
        padding: 5px 0;
      }

      .task-dates {
        width: 180px;
        text-align: right;
        color: var(--muted);
        font-size: 12px;
        white-space: nowrap;
      }
      .task-dur {
        align-items: right;
        justify-content: flex-start; /* keeps text aligned right even in flex */
        padding-left: 8px;
        font-size: 12px;
        color: var(--muted);
        box-sizing: border-box;
      }

      /* Fix inline duration editor input alignment */
      .task-dur input {
        height: 24px; /* matches row text height */
        line-height: 24px;
        padding: 0 4px;
        margin: 0;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        font-size: 12px;
        box-sizing: border-box;
        width: 40px; /* small width, fits the cell */
      }

      /* right cell of unified row: the per-row grid area */
      .row-right {
        flex: 1;
        min-width: 0;
        position: relative;

        box-sizing: border-box;
      }

      .row-grid {
        width: 100%;
        height: 100%;
        min-height: var(--row-height);
      }

      .grid-back {
        position: absolute;
        inset: 0;
        background-image: repeating-linear-gradient(
          to right,
          rgba(15, 23, 42, 0.03) 0,
          rgba(15, 23, 42, 0.03) 1px,
          transparent 1px,
          transparent var(--scale)
        );
        background-color: var(--grid-bg);
      }

      .bar {
        position: absolute;
        height: var(--bar-height);
        border-radius: 6px;
        background: var(--accent);
        color: white;
        display: flex;
        align-items: center;
        padding-right: 6px;
        box-sizing: border-box;
        cursor: grab;
      }
      .bar .label {
        position: absolute;
        left: 6px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: calc(100% - 20px);
      }
      .bar .handle {
        width: 10px;
        height: 100%;
        cursor: ew-resize;
      }

      /* dependency overlay spanning right column (SVG placed here) */
      .dep-overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      /* add-task area at bottom */
      .add-task-panel {
        padding: 12px;
      }
      .add-task {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      @media (max-width: 800px) {
        .gantt-left {
          display: none;
        } /* optional for small screens */
      }
    </style>
  </head>

  <body>
    <div class="app">
      <!-- Header -->
      <div class="panel header-panel">
        <div class="header-left">
          <div class="title">
            Project Schedule for <span id="acRegLabel">AC REG</span>
          </div>
          <div style="font-size: 12px; color: var(--muted)">
            Select a WO to load its tasks
          </div>
        </div>
        <div class="header-controls">
          <select id="woFilter" style="min-width: 220px">
            <option value="">Select Work Order</option>
          </select>
        </div>
      </div>

      <!-- GANTT unified panel -->
      <div
        class="panel gantt-panel"
        style="display: flex; flex-direction: column; flex: 1; min-height: 0"
      >
        <div class="gantt-scroll" id="ganttScroll">
          <div class="gantt-inner">
            <!-- LEFT column (task info) -->
            <div class="gantt-left">
              <div
                class="left-header"
                style="
                  display: flex;
                  align-items: center;
                  font-size: 12px;
                  padding: 30px 12px 2px;
                  box-sizing: border-box;
                  gap: 16px;
                "
              >
                <div
                  style="width: 16px; color: var(--muted); text-align: center"
                >
                  #
                </div>

                <div
                  style="flex: 1; min-width: 0; color: #111; padding-left: 4px"
                >
                  Task Name
                </div>

                <div
                  style="width: 50px; text-align: center; color: var(--muted)"
                >
                  Dur
                </div>

                <div
                  style="width: 165px; text-align: center; color: var(--muted)"
                >
                  Start â†’ End
                </div>
              </div>

              <div id="taskLeftList" class="rows-container"></div>
            </div>

            <!-- RIGHT column (timeline) -->
            <div class="gantt-right">
              <div id="timelineHeader" class="timeline-header"></div>
              <div
                id="rowsRight"
                class="rows-container"
                style="position: relative"
              ></div>

              <!-- dependency overlay sits on top of right column content -->
              <div id="depOverlay" class="dep-overlay"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- ADD TASK -->
      <div class="panel add-task-panel">
        <div class="add-task">
          <input id="newTitle" type="text" placeholder="Task name" />
          <input id="newStart" type="date" />
          <input id="newEnd" type="date" />
          <select id="newDepends">
            <option value="">No dependency</option>
          </select>
          <button id="addTaskBtn" class="btn">Add</button>
        </div>
      </div>
    </div>

    <!-- Firebase SDK + app logic -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import {
        getFirestore,
        collection,
        addDoc,
        doc,
        updateDoc,
        deleteDoc,
        onSnapshot,
        serverTimestamp,
        getDocs,
        query,
        where,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyCMA528UF3Di50hAhK3ytMaRPTXo8_syDY",
        authDomain: "projectscheduler-ea4fe.firebaseapp.com",
        projectId: "projectscheduler-ea4fe",
        storageBucket: "projectscheduler-ea4fe.firebasestorage.app",
        messagingSenderId: "397430880860",
        appId: "1:397430880860:web:4c31f8b0f49afe7222c499",
      };

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const tasksCol = collection(db, "tasks");
      let tasks = [];

      // DOM references
      const ganttScroll = document.getElementById("ganttScroll");
      const taskLeftList = document.getElementById("taskLeftList");
      const rowsRight = document.getElementById("rowsRight");
      const timelineHeader = document.getElementById("timelineHeader");
      const depOverlay = document.getElementById("depOverlay");
      const newDepends = document.getElementById("newDepends");

      // helper date utils
      const DAY_MS = 86400000;
      let scale = 36;

      function toUTC(d) {
        return new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
      }
      function addDays(d, n) {
        const x = new Date(d);
        x.setDate(x.getDate() + n);
        x.setHours(0, 0, 0, 0);
        return toUTC(x);
      }
      function formatDate(d) {
        if (!d || isNaN(d.getTime())) return "Invalid";
        return d.toISOString().slice(0, 10);
      }
      function daysBetween(a, b) {
        return Math.round((b - a) / DAY_MS);
      }

      // Populate WO dropdown by collecting unique WOs
      async function loadWOList() {
        const woFilter = document.getElementById("woFilter");
        try {
          const snap = await getDocs(tasksCol);
          const unique = new Map();
          snap.forEach((d) => {
            const data = d.data();
            if (data.wo) unique.set(String(data.wo), data.acreg || "AC REG");
          });
          woFilter.innerHTML = `<option value="">Select Work Order</option>`;
          unique.forEach((acreg, wo) => {
            woFilter.innerHTML += `<option value="${wo}" data-acreg="${acreg}">${wo} â€” ${acreg}</option>`;
          });
        } catch (err) {
          console.error("loadWOList failed", err);
        }
      }
      loadWOList();

      // When a WO is selected, subscribe to its tasks
      let unsubscribeTasks = null;
      document.getElementById("woFilter").addEventListener("change", (e) => {
        const wo = e.target.value;
        const sel = e.target.selectedOptions[0];
        document.getElementById("acRegLabel").textContent = sel
          ? sel.dataset.acreg
          : "AC REG";

        if (unsubscribeTasks) unsubscribeTasks();

        if (!wo) {
          tasks = [];
          render();
          return;
        }

        const q = query(tasksCol, where("wo", "==", wo));
        unsubscribeTasks = onSnapshot(q, (snapshot) => {
          tasks = snapshot.docs.map((d) => {
            const data = d.data();
            return {
              id: d.id,
              wo: data.wo,
              acreg: data.acreg,
              taskno: data.taskno || 999999,
              title: data.title || "",
              start: new Date(data.start),
              end: new Date(data.end),
              depends: data.depends || "",
              dependencies: data.dependencies || "",
            };
          });

          // sort by start then taskno
          tasks.sort((a, b) => {
            const s = a.start - b.start;
            if (s !== 0) return s;
            return (a.taskno || 999999) - (b.taskno || 999999);
          });

          applyDependencies();
          render();
        });
      });

      async function saveTask(task) {
        const ref = doc(db, "tasks", task.id);
        await updateDoc(ref, {
          title: task.title,
          start: task.start.toISOString(),
          end: task.end.toISOString(),
          depends: task.depends || "",
          updatedAt: serverTimestamp(),
        });
      }

      document.getElementById("addTaskBtn").onclick = async () => {
        const wo = document.getElementById("woFilter").value;
        if (!wo) return alert("Select a Work Order first!");
        const acreg =
          document.getElementById("woFilter").selectedOptions[0].dataset.acreg;

        const title = document.getElementById("newTitle").value.trim();
        const s = document.getElementById("newStart").value;
        const e = document.getElementById("newEnd").value;
        const dep = document.getElementById("newDepends").value || "";

        if (!title || !s || !e) return alert("Missing fields!");

        await addDoc(tasksCol, {
          wo,
          acreg,
          title,
          start: new Date(s).toISOString(),
          end: new Date(e).toISOString(),
          depends: dep,
          taskno: Date.now(),
          updatedAt: serverTimestamp(),
        });
      };

      // dependency adjustment loop
      function applyDependencies() {
        const map = Object.fromEntries(tasks.map((t) => [t.id, t]));
        let changed = true,
          safety = 0;
        while (changed && safety++ < 50) {
          changed = false;
          tasks.forEach((t) => {
            if (!t.depends) return;
            const p = map[t.depends];
            if (!p) return;
            const minStart = addDays(p.end, 1);
            if (t.start < minStart) {
              const dur = daysBetween(t.start, t.end);
              t.start = toUTC(minStart);
              t.end = addDays(t.start, dur);
              changed = true;
            }
          });
        }
      }

      // Rendering: header days + unified rows (left + right) + bars inside right row-grid
      function getBounds() {
        if (!tasks.length)
          return [addDays(new Date(), -3), addDays(new Date(), 10)];
        let min = tasks[0].start,
          max = tasks[0].end;
        tasks.forEach((t) => {
          if (t.start < min) min = t.start;
          if (t.end > max) max = t.end;
        });
        return [addDays(min, -3), addDays(max, 3)];
      }

      function render() {
        // populate depends select
        newDepends.innerHTML =
          '<option value="">No dependency</option>' +
          tasks
            .map((t) => `<option value="${t.id}">${t.title}</option>`)
            .join("");

        // clear left & right rows
        taskLeftList.innerHTML = "";
        rowsRight.innerHTML = "";
        depOverlay.innerHTML = "";

        const [minDate, maxDate] = getBounds();
        const totalDays = daysBetween(minDate, maxDate) + 1;
        const width = totalDays * scale;

        // build timeline header (days row)
        timelineHeader.innerHTML = "";
        const headInner = document.createElement("div");
        headInner.style.display = "flex";
        headInner.style.minWidth = width + "px";
        headInner.style.boxSizing = "border-box";

        for (let i = 0; i < totalDays; i++) {
          const d = addDays(minDate, i);
          const cell = document.createElement("div");
          cell.style.width = scale + "px";
          cell.style.minWidth = scale + "px";
          cell.style.height = "30px";
          cell.style.display = "flex";
          cell.style.alignItems = "center";
          cell.style.justifyContent = "center";
          cell.style.boxSizing = "border-box";
          cell.style.borderRight = "1px solid rgba(0,0,0,0.06)";
          cell.textContent = d.getDate();
          headInner.appendChild(cell);
        }

        timelineHeader.appendChild(headInner);

        const rowH =
          parseInt(
            getComputedStyle(document.documentElement).getPropertyValue(
              "--row-height"
            )
          ) || 44;

        const barH =
          parseInt(
            getComputedStyle(document.documentElement).getPropertyValue(
              "--bar-height"
            )
          ) || 20;

        // build rows left + right
        tasks.forEach((task, idx) => {
          // LEFT
          const leftRowWrapper = document.createElement("div");
          leftRowWrapper.className = "unified-row";

          const leftCell = document.createElement("div");
          leftCell.className = "row-left";
          leftCell.innerHTML = `
        <div class="index">${idx + 1}</div>
        <div class="task-title">${task.title}</div>
        <div class="task-dur" data-id="${task.id}">
            <span class="dur-text">${
              daysBetween(task.start, task.end) + 1
            }d</span>
        </div>
        <div class="task-dates">${formatDate(task.start)} â†’ ${formatDate(
            task.end
          )}</div>
    `;

          leftRowWrapper.appendChild(leftCell);
          taskLeftList.appendChild(leftRowWrapper);

          // RIGHT
          const rightRowWrapper = document.createElement("div");
          rightRowWrapper.className = "unified-row";
          rightRowWrapper.style.minWidth = "0";

          const rightCell = document.createElement("div");
          rightCell.className = "row-right";

          const rowGrid = document.createElement("div");
          rowGrid.className = "row-grid";
          rowGrid.style.minWidth = width + "px";

          const gridBack = document.createElement("div");
          gridBack.className = "grid-back";
          gridBack.style.minWidth = width + "px";

          const bar = document.createElement("div");
          bar.className = "bar";
          bar.dataset.id = task.id;

          const leftDays = daysBetween(minDate, task.start);
          const span = daysBetween(task.start, task.end) + 1;

          bar.style.left = leftDays * scale + "px";
          bar.style.width = span * scale + "px";
          bar.style.fontSize = "12px";
          bar.style.height = barH + "px";
          bar.innerHTML = `
        <div class="handle left"></div>
        <div class="label">${task.title}</div>
        <div class="handle right"></div>
    `;

          rowGrid.appendChild(gridBack);
          rowGrid.appendChild(bar);
          rightCell.appendChild(rowGrid);
          rightRowWrapper.appendChild(rightCell);
          rowsRight.appendChild(rightRowWrapper);
        });

        // ðŸ”¥ NEW FIX: MATCH RIGHT ROW HEIGHT TO LEFT ROW HEIGHT
        // ðŸ”¥ FINAL FIX: FORCE RIGHT ROWS TO MATCH LEFT ROW HEIGHT EXACTLY
        requestAnimationFrame(() => {
          const leftRows = taskLeftList.querySelectorAll(".unified-row");
          const rightRows = rowsRight.querySelectorAll(".unified-row");

          rightRows.forEach((rightRow, i) => {
            const leftH = leftRows[i].offsetHeight;

            // Unified row itself
            rightRow.style.height = leftH + "px";

            // Child elements
            const rowRight = rightRow.querySelector(".row-right");
            if (rowRight) rowRight.style.height = leftH + "px";

            const rowGrid = rightRow.querySelector(".row-grid");
            if (rowGrid) rowGrid.style.height = leftH + "px";

            const gridBack = rightRow.querySelector(".grid-back");
            if (gridBack) gridBack.style.height = leftH + "px";

            // Recenter bar
            const bar = rightRow.querySelector(".bar");
            if (bar) {
              const barH = bar.offsetHeight;
              bar.style.top = Math.round((leftH - barH) / 2) + "px";
            }
          });

          drawDeps(minDate, scale, width);
        });

        attachDurationEditing();

        rowsRight.querySelectorAll(".bar").forEach((b) => makeDraggable(b));
      }
      // end render

      // Draw dependencies as paths placed into depOverlay (SVG)
      // Replace current drawDeps(...) with this
      function drawDeps(minDate, scale, width) {
        // remove any previous svg inside rowsRight
        const prev = rowsRight.querySelector("svg.__deps_svg");
        if (prev) prev.remove();

        if (!tasks.length) return;

        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.classList.add("__deps_svg");
        // Make the SVG use the grid's pixel coordinate system
        svg.setAttribute("width", width + "px");
        svg.setAttribute("height", rowsRight.scrollHeight + "px");
        svg.style.position = "absolute";
        svg.style.left = "0px";
        svg.style.top = "0px";
        svg.style.pointerEvents = "none";
        svg.style.overflow = "visible";
        svg.style.zIndex = 2; // above grid but below bar labels if needed

        const rowH =
          parseInt(
            getComputedStyle(document.documentElement).getPropertyValue(
              "--row-height"
            )
          ) || 44;

        tasks.forEach((t, i) => {
          if (!t.depends) return;
          const parent = tasks.find((x) => x.id === t.depends);
          if (!parent) return;
          const pIndex = tasks.indexOf(parent);
          const cIndex = i;

          const px = (daysBetween(minDate, parent.end) + 1) * scale;
          const tx = daysBetween(minDate, t.start) * scale;

          // Use rowsRight children (same coordinate space as the SVG)
          const pRightRow = rowsRight.children[pIndex];
          const cRightRow = rowsRight.children[cIndex];

          if (!pRightRow || !cRightRow) return; // safety

          const py = pRightRow.offsetTop + pRightRow.offsetHeight / 2;
          const ty = cRightRow.offsetTop + cRightRow.offsetHeight / 2;

          const path = document.createElementNS(svgNS, "path");
          path.setAttribute(
            "d",
            `M ${px} ${py} C ${px + 40} ${py} ${tx - 40} ${ty} ${tx} ${ty}`
          );
          path.setAttribute("stroke", "#94a3b8");
          path.setAttribute("fill", "none");
          path.setAttribute("stroke-width", "1.5");
          svg.appendChild(path);
        });

        // Insert the svg into rowsRight (so it participates in the same scroll/content box)
        rowsRight.appendChild(svg);
      }

      // Dragging & resizing logic (works with bars inside each row-grid)
      function makeDraggable(el) {
        let dragging = false,
          mode = null;
        let startX = 0,
          origLeft = 0,
          origWidth = 0;

        const id = el.dataset.id;
        const leftHandle = el.querySelector(".handle.left");
        const rightHandle = el.querySelector(".handle.right");

        leftHandle.addEventListener("mousedown", (e) => start("left", e));
        rightHandle.addEventListener("mousedown", (e) => start("right", e));
        el.addEventListener("mousedown", (e) => start("move", e));

        function start(m, e) {
          e.preventDefault();
          dragging = true;
          mode = m;
          startX = e.clientX;
          origLeft = parseFloat(el.style.left) || 0;
          origWidth =
            parseFloat(el.style.width) || parseFloat(el.style.width) || scale;
          document.body.style.userSelect = "none";
          window.addEventListener("mousemove", move);
          window.addEventListener("mouseup", end);
        }

        function move(e) {
          if (!dragging) return;
          const dx = e.clientX - startX;
          if (mode === "move") {
            el.style.left = Math.max(0, origLeft + dx) + "px";
          } else if (mode === "left") {
            const newLeft = origLeft + dx;
            const newWidth = origWidth - dx;
            el.style.left = Math.max(0, newLeft) + "px";
            el.style.width = Math.max(scale, newWidth) + "px";
          } else if (mode === "right") {
            el.style.width = Math.max(scale, origWidth + dx) + "px";
          }
        }

        async function end() {
          dragging = false;
          document.body.style.userSelect = "auto";
          window.removeEventListener("mousemove", move);
          window.removeEventListener("mouseup", end);

          const [minDate] = getBounds();
          const leftPx = parseFloat(el.style.left);
          const widthPx = parseFloat(el.style.width);

          const leftDays = Math.round(leftPx / scale);
          const spanDays = Math.max(1, Math.round(widthPx / scale));

          const t = tasks.find((x) => x.id === id);
          if (!t) return;
          t.start = addDays(minDate, leftDays);
          t.end = addDays(t.start, spanDays - 1);

          applyDependencies();
          render();

          try {
            await saveTask(t);
          } catch (err) {
            console.error("save failed", err);
          }
        }
      }

      // duration editing (click on duration cell in left list)
      function attachDurationEditing() {
        // add click handlers for left column duration cells
        taskLeftList.querySelectorAll(".task-dur").forEach((cell) => {
          cell.onclick = () => {
            const id = cell.dataset.id;
            const t = tasks.find((x) => x.id === id);
            if (!t || cell.querySelector("input")) return;
            const cur = daysBetween(t.start, t.end) + 1;
            cell.innerHTML = `<input type="number" min="1" value="${cur}">`;
            const input = cell.querySelector("input");
            input.focus();
            input.select();
            const commit = () => {
              const v = Math.max(1, Number(input.value));
              t.end = addDays(t.start, v - 1);
              applyDependencies();
              render();
              saveTask(t).catch((e) => console.error(e));
            };
            input.addEventListener("blur", commit, { once: true });
            input.addEventListener("keydown", (e) => {
              if (e.key === "Enter") input.blur();
              if (e.key === "Escape") render();
            });
          };
        });
      }
      ganttScroll.addEventListener("scroll", () => {
        // If a deps svg exists inside rowsRight, update its height (and width if timeline changed)
        const svg = rowsRight.querySelector("svg.__deps_svg");
        if (svg) {
          svg.setAttribute("height", rowsRight.scrollHeight + "px");
          // optional: update width when horizontal range changes
          // svg.setAttribute("width", /* new width */);
        }
      });

      // default new task dates
      document.getElementById("newStart").value = formatDate(
        addDays(new Date(), 1)
      );
      document.getElementById("newEnd").value = formatDate(
        addDays(new Date(), 3)
      );

      // initial empty render (until WO selected)
      render();
    </script>
  </body>
</html>
